name: Deploy EC2 com Ansible

on:
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

env:
  env:
  AWS_REGION: "us-east-1"
  TF_VERSION: "1.5.0"
  S3_BUCKET: "meu-bucket-ansible1"
  DYNAMODB_TABLE: "lock-ansible"
  OUTPUTS_S3_PATH: "s3://meu-bucket-terraform-github-actions-uc-20/outputs/terraform_outputs.env"
  PRIVATE_KEY_S3_PATH: "s3://meu-bucket-terraform-github-actions-uc-20/outputs/id_rsa.pem"
  PRIVATE_KEY_LOCAL_PATH: "/tmp/id_rsa.pem"
  PRIVATE_KEY_AUX_PATH: "/tmp/id_rsa_aux.pem"
  INVENTORY_S3_PATH: "s3://meu-bucket-terraform-github-actions-uc-20/outputs/inventory"
  INVENTORY_LOCAL_PATH: "/tmp/inventory"  # Caminho local para onde o inventory serÃ¡ baixado


jobs:
  ansible:
    name: "Ansible"
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Assume AWS Role
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: ${{ secrets.AWS_ASSUME_ROLE_ARN }}
          role-session-name: GitHub_to_AWS_via_FederatedOIDC
          aws-region: ${{ env.AWS_REGION }}


      - name: Criar S3 Bucket (se nÃ£o existir)
        run: |
          if aws s3 ls "s3://${{ env.S3_BUCKET }}" 2>&1 | grep -q 'NoSuchBucket'; then
            echo "Bucket nÃ£o existe. Criando..."
            aws s3 mb s3://${{ env.S3_BUCKET }} --region ${{ env.AWS_REGION }}
          else
            echo "Bucket jÃ¡ existe. Pulando criaÃ§Ã£o."
          fi
      - name: Criar diretÃ³rio no S3 para outputs (se necessÃ¡rio)
        run: |
          echo "ðŸ—‚ Criando diretÃ³rio no S3 para os outputs..."
          aws s3api put-object --bucket ${{ env.S3_BUCKET }} --key "outputs/"
    
      - name: Criar Tabela DynamoDB (se nÃ£o existir)
        run: |
          if aws dynamodb describe-table --table-name ${{ env.DYNAMODB_TABLE }} 2>&1 | grep -q 'ResourceNotFoundException'; then
            echo "Tabela DynamoDB nÃ£o existe. Criando..."
            aws dynamodb create-table \
              --table-name ${{ env.DYNAMODB_TABLE }} \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST
          else
            echo "Tabela jÃ¡ existe. Pulando criaÃ§Ã£o."
          fi

  apply:
    name: "Terraform-Ansible Init - Plan - Apply"
    runs-on: ubuntu-latest
    needs: ansible
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Assume AWS Role
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: ${{ secrets.AWS_ASSUME_ROLE_ARN }}
          role-session-name: GitHub_to_AWS_via_FederatedOIDC
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Init na Raiz
        run: terraform init -reconfigure
        working-directory: .

      # ðŸ“¥ **Baixar outputs do Terraform do S3**
      - name: Baixar outputs do Terraform do S3
        run: |
          echo "ðŸ“¥ Baixando outputs do Terraform..."
          aws s3 cp ${{ env.OUTPUTS_S3_PATH }} terraform_outputs.env --region ${{ env.AWS_REGION }}

          if [ -f terraform_outputs.env ]; then
            echo "âœ… Arquivo terraform_outputs.env baixado com sucesso."
            cat terraform_outputs.env
          else
            echo "âŒ ERRO: Arquivo terraform_outputs.env NÃƒO encontrado!"
            exit 1
          fi

      # ðŸ“Œ **Carregar os outputs como variÃ¡veis de ambiente**
      - name: Carregar Outputs do Terraform
        run: |
          echo "ðŸ“‚ Carregando outputs do Terraform..."
          source terraform_outputs.env

          while IFS='=' read -r key value; do
            if [[ -n "$key" && ! "$key" =~ ^# ]]; then
              value=$(echo "$value" | tr -d '"' | tr -d "'")  
              value=$(echo "$value" | xargs)  
              echo "$key=$value" >> $GITHUB_ENV
            fi
          done < terraform_outputs.env

      - name: Debug Terraform Outputs
        run: |
          echo "âœ… Debug dos valores extraÃ­dos do Terraform:"
          echo "VPC_ID=${{ env.VPC_ID }}"
          echo "SUBNET_ID=${{ env.SUBNET_ID }}"
          echo "KEY_PAIR_NAME=${{ env.KEY_PAIR_NAME }}"
          echo "PRIVATE_KEY=***SECRETO***"

      # ðŸ“¥ **Baixar chave privada do S3**
      - name: Baixar chave privada do S3
        run: |
          echo "ðŸ“¥ Baixando chave privada do S3..."
          aws s3 cp ${{ env.PRIVATE_KEY_S3_PATH }} ${{ env.PRIVATE_KEY_LOCAL_PATH }} --region ${{ env.AWS_REGION }}
          chmod 600 ${{ env.PRIVATE_KEY_LOCAL_PATH }}

      # ðŸ“¥ **Criar e verificar um ficheiro auxiliar da chave privada**
      - name: Criar ficheiro auxiliar da chave privada
        run: |
          echo "ðŸ“¥ Criando e verificando ficheiro auxiliar..."
          cp ${{ env.PRIVATE_KEY_LOCAL_PATH }} ${{ env.PRIVATE_KEY_AUX_PATH }}
          chmod 600 ${{ env.PRIVATE_KEY_AUX_PATH }}

          echo "ðŸ” ConteÃºdo do ficheiro auxiliar id_rsa_aux.pem: - VER - VER-VER "
          cat ${{ env.PRIVATE_KEY_AUX_PATH }}
          echo "ðŸ” Fim do conteÃºdo. - VISTO - VISTO"

      # â˜ï¸ **Enviar chave auxiliar para o S3 novamente (Backup)**
      - name: Enviar chave auxiliar para o S3 (Backup)
        run: |
          echo "ðŸ“¤ Enviando chave auxiliar de volta ao S3..."
          aws s3 cp ${{ env.PRIVATE_KEY_AUX_PATH }} s3://meu-bucket-terraform-github-actions-uc-20/outputs/id_rsa_aux.pem --region ${{ env.AWS_REGION }}





      # ðŸ“Œ **Executar Terraform no diretÃ³rio Ansible**
      - name: Terraform Init (Ansible)
        run: |
          cd ansible
          terraform init -reconfigure

      - name: Terraform Plan (Ansible)
        run: |
          cd ansible
          terraform plan -var "vpc_id=${{ env.VPC_ID }}" \
                         -var "subnet_id=${{ env.SUBNET_ID }}" \
                         -var "key_pair_name=${{ env.KEY_PAIR_NAME }}" \
                         -var "private_key_pem=$(cat ${{ env.PRIVATE_KEY_LOCAL_PATH }})" \
                         -out=tfplan

      - name: Terraform Apply (Ansible)
        run: |
          cd ansible
          terraform apply -var "vpc_id=${{ env.VPC_ID }}" \
                          -var "subnet_id=${{ env.SUBNET_ID }}" \
                          -var "key_pair_name=${{ env.KEY_PAIR_NAME }}" \
                          -var "private_key_pem=$(cat ${{ env.PRIVATE_KEY_LOCAL_PATH }})" \
                          -auto-approve
